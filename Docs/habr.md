# Содержание

1. Введение
1. Обзор системы сборки Bazel
1. Фреймворк Mediapipe
    1. Что такое Mediapipe. Из чего состоит и зачем нужен.
    1. HelloWorld приложение на Mediapipe
    1. Запуск модели с помощью Mediapipe
1. Создание приложение с помощью Mediapipe
1. Заключение


# Введение 
Мотивация, класс приложений и т.д.

# Обзор системы сборки Bazel

В mediapipe для сборки используется Bazel. Я столкнулся с этой системой сборки впервые, поэтому параллельно с Mediapipe разбирался c Bazel, собирая информацию с разных источников и наступая на грабли. Поэтому, перед тем, как рассказать о самом Mediapipe, мне хотелось бы дать небольшое введение по системе сборки Bazel, которая используется в фреймворке и с которой я столкнулся впервые. Bazel - система сборки от Google, доработанная версия их внутренней системы сборки Blaze, выложенная в общий доступ. Bazel позволяет в одном проекте объединять различные языки и фреймворки простой командой:

`bazel build TARGET`

Как система сборки понимает, какой именно инструмент необходимо использовать для того или иного таргета? Для начала необходимо понять, из чего складывается Bazel-проект. Главным файлом проекта является текстовый файл WORKSPACE, в котором указываются все зависимости проекта. Говоря обо всех зависимостях, подразумеваются транзитивные зависимости тоже. Иными словами, если проект зависит от A, который зависит от B, то необходимо будет указать в WORKSPACE файле как зависимость от A, так и от B. Из-за этого WORKSPACE может сильно разрастаться, что можно будет заметить в дальнейшем примере работы с Mediapipe. Разработчики Bazel объясняют такое решение тем, что при изменении у зависимостей проекта их зависимостей, которые используются в проекте, проект может ломаться и искать проблему становится очень сложно, поэтому требуется явно указать всё, от чего зависит проект. Вот как может выглядить пример файла WORKSPACE:

```
# Загрузка правила для получения зависимостей скачиванием
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

# Скачивание зависимости с набором правил для сборки c++
http_archive(
    name = "rules_cc",
    strip_prefix = "rules_cc-master",
    urls = ["https://github.com/bazelbuild/rules_cc/archive/master.zip"],
)

# Скачивание зависимости googletest
http_archive(
    name = "com_google_googletest",
    strip_prefix = "googletest-master",
    urls = ["https://github.com/google/googletest/archive/master.zip"],
)
```

Как видно из примера, файл состоит из правил (bazel rule). Каждое из этих правил - функция на языке Starlark. В этом и заключается расширяемость и универсальность Bazel. С помощью правил можно добавлять в систему сборки новые возможности, новые языки. Например, в указанном выше примере сначала загружается правило http_archive для загрузки зависимостей, а затем с помощью http_archive загружается набор правил для сборки C++ проектов и библиотека googletest.

Помимо файла WORKSPACE любой Bazel проект содержит некоторое количество файлов BUILD. BUILD файл описывает директорию, в которой он находится, как модуль и содержит описание таргетов для сборки. Вот так выглядит BUILD файл для сборки C++ проекта с одним файлом:

```
cc_binary(
    name="HelloWorld",
    srcs=["main.cpp"],
    copts=["-Wall", "-Wpedantic", "-Werror"]
)
```

Здесь используется единственное правило, которое было загружено в файле WORKSPACE с помощью http_archive, создающее таргет для сборки. Пусть проект состоит из трех файлов:

* ./WORKSPACE
* ./Source/BUILD
* ./Source/main.cpp

Для сборки этого проекта достаточно выполнить команду

`bazel build //Source:HelloWorld`

Source - модуль, HelloWorld - таргет.

Правило вызовет cmake, результат сборки(исполняемый файл) будет расположен в ./bazel-bin.

Добавлять всё зависимости и исходники таргета одно правило часто может быть затруднительно, правила могут разрастаться и быть трудноподдерживаемыми, а также много кода может дублироваться. Для решения данной проблемы в Bazel есть библиотеки (libraries). 

```
cc_library(
    name = "lib",
    hdrs = ["utils.h"],
    srcs = ["utils.cpp"],
    visibility = [
        "//visibility:public",
    ],
)

cc_binary(
    name="HelloWorld",
    srcs=["main.cpp"],
    deps=[":lib"],
    copts=["-Wall", "-Wpedantic", "-Werror"]
)
```

Библиотеки могут располагаться как в одном BUILD файле, так и в разных модулях или в разных проектах. Чтобы указать зависимость от модуля в другом проекте, необходимо до // написать название проекта

`@some_repository//Module:lib`

Bazel содержит набор встроенных правил, подходящих для большинства случаев. Помимо http_archive, зависимости можно добавлять с помощью git_repository, local_repository и др.


# Обзор Mediapipe

## Что такое Mediapipe

Mediapipe - кроссплатформенный фреймворк для запуска пайплайнов машинного обучения. Сам пайплайн задается в форме графа, граф состоит из следующих компонент (в скобках указывается оригинальный термин):

1. Вершины графа (Calculators) - некоторые преобразования. Представляют из себя C++ класс, реализующий интерфейс CalculatorBase, состоящий из следующих функций:
* `static Status GetContract(CalculatorContract*);` - статический метод, в котором калькулятор описывает форматы данных, которые ждет на вход и готов отдать на выход.
* `Status Open(CalculatorContext*);` - инициализация калькулятора при создании графа. Здесь, например, может быть загрузка данных, требуемых для работы.
* `Status Process(CalculatorContext*);` - обработка поступившего пакета.
* `Status Close(CalculatorContext*);` - закрытие вершины.

У каждого калькулятора должен быть как минимум один входящий и как минимум один исходящий поток.

2. Ребра графа (Streams) задают связи между калькуляторами. С помощью потоков по графу перемещаются пакеты с данными. Поток может быть внутренний, входной (input) и исходящий (output). Внутренний поток соединяет два калькулятора, по входному потоку из внешнего кода в граф попадают данные, а с помощью исходящего потока граф отправляет данные наружу, в вызывающий код.

3. Пакет (Packet) - единица данных, перемещаемая по графу и обрабатываемая калькулятором. Каждый пакет несёт в себе данные определенного типа - это может быть строка, целое число, массив чисел с плавающей запятой или пользовательский тип, описанный и сериализуемый в protobuf. Каждый пакет содержит в себе timestamp - отметку времени, ассоциированную с пакетом. Необходима для того, чтобы отличать, какой пакет был раньше, какой позже, напрямую с реальным временем не связано.

Графы описываются в формате protobuf. TODO?

Фреймворк позволяет из калькуляторов составлять необходимый пайплайн для инференса модели, а затем просто встраивать ее в приложения на разных платформах. Сейчас разработчики заявляют о поддержке нескольких дистрибутивов Linux, WSL, MacOS, Android, iOS. Вместе с фреймворком поставляется tflite для запуска моделей. Поддержки других фреймворков машинного обучения сейчас нет, но так как можно создавать собственные калькуляторы и встраивать их в граф, то возможность добавления поддержки других фреймворков есть.

Далее на примерах показано, как использовать Mediapipe. Здесь будут разобраны самые примитивные примеры, показывающие решение упрощенных учебных задач. Более сложные и практические примеры есть в репозитории Mediapipe, но разбираться с нуля по ним может быть сложно, полезно начинать с чего-то максимально простого.

## HelloWorld приложение на Mediapipe

Для начала можно рассмотреть самый простой граф, состоящий из одного узла, который повторяет N раз пакет, полученный на вход.

Входной пакет -> RepeatNTimesNode -> Выходной пакет.

Вот как выглядит pbtxt этого файла
...

Вот как выглядит код калькулятора
...

Вот протобаф с настройками калькулятора
...

main.cpp для запуска графа
...

Собираем, запускаем смотрим: 
...
вставить скрин запуска

Данный пример демонстрирует пример запуска графа Mediapipe, однако не имеет отношения к запуску ML моделей.

## Запуск модели с помощью Mediapipe

Теперь рассмотрим, как с помощью Mediapipe запускать инференс моделей на разных устройствах. Дана обученная сеть, сконвертированная в tflite формат, обученная на ImageNet и классифицирующая на 1000 классов. Требуется написать программу для десктопа и смартфона (Android), запускающую данную сетку и выполняющую классификацию переданной фотографии. Пайплайн для запуска такого приложения можно собрать из стандартных калькуляторов, вот как он будет выглядеть:

Входное изображение -> ImageTransformationCalculator-> TfLiteConverterCalculator -> TfLiteInferenceCalculator -> TfLiteTensorsToFloatsCalculator -> Вектор предсказаний

TODO здесь текст этого файла.

Граф содержит 4 узла: 

1. Изменение размера входного изображения на 224x224. Изображение можно отдать в приложение какого угодно размера, но сеть ожидает 224x224.
1. Нормализация на диапазон [-1, 1] (параметр калькулятора zero_center: false, по умолчанию нормализация проводится на [0, 1]), а затем преобразование из изображения в tf тензор.
1. Запуск модели.
1. Преобразование выходного тезнора в вектор чисел. Вектор предсказаний будет отдан вызывающему коду.

Вызывающий код для графа

Пример как запустить на десктопе
...
вставить скрин запуска

Пример как запустить на андроиде
...
вставить скрин запуска


Полный код составленных примеров можно посмотреть на Github:
TODO


# Создание приложение с помощью Mediapipe

Теперь рассмотрим более практический пример. Представим сервис по распознаванию моделей автомобилей. Есть приложение, через которое можно сфотографировать авто и отправить на сервер. Есть сервер, который для присланной фотографии запускает модель классификации и отдает полученный результат на клиент. Количество пользователей растет, нагрузка на сервер тоже и требуется решать проблему производительности:

* Добавить еще мощности для сервера, докупить GPU, добавить несколько серверов.
* Перенести часть вычислений на клиент.

Выбираем второй вариант, для его реализации можно воспользоваться Mediapipe. Теперь приложение должно не только снимать автомобиль, но также находить в кадре и переводить его в некоторый вектор чисел, потому что передавать по сети 1000 чисел проще, чем целое изображение. Для этого потребуется две модели: модель детекции и модель для векторизации.

За основу приложения был взят пример для Mediapipe, решающий задачу детекции. Для получения вектора из фотографии взята сеть, обученная на ImageNet, далее дообучения на датасете из автомобилей. Векторное представление автомобиля получается из значений перед первым полносвязным слоем.

Исходный граф из примера и модифицированный для решения задачи:

Здесь можно показать исходный граф и модифицированный граф

Как фильтровать детекшены...

Как отправлять тапы в граф...

Как вырезать bbox и отправлять его в классификатор...

Пару слов о том, что представляет из себя сетка, векторизирующая фотку.

Отправка на сервер и обработка на сервере...

Что получилось, какой результат, что можно улучшить

# Типичные ошибки
...

# Заключение




Добавить описание форматов timestamp, string, protobuf.

Про линковку в базеле рассказать.

Больше текста.

Уменьшить apk